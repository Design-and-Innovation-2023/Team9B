"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _UARTClass_instances, _UARTClass_debug, _UARTClass_flowControl, _UARTClass_queue, _UARTClass_sentChunks, _UARTClass_connection, _UARTClass_endpoints, _UARTClass_handleQueue, _UARTClass_log, _UARTClass_checkIfSupported;
Object.defineProperty(exports, "__esModule", { value: true });
exports.uart = void 0;
const stringArrayBuffer_1 = require("./helpers/stringArrayBuffer");
const modal_1 = require("./styles/modal");
const isIOS_1 = require("./helpers/isIOS");
class UARTClass {
    constructor(options) {
        _UARTClass_instances.add(this);
        _UARTClass_debug.set(this, 3);
        this.isBusy = false;
        _UARTClass_flowControl.set(this, true);
        _UARTClass_queue.set(this, []);
        _UARTClass_sentChunks.set(this, []);
        _UARTClass_connection.set(this, void 0);
        _UARTClass_endpoints.set(this, [
            {
                name: "Web Bluetooth",
                description: "Bluetooth LE devices",
                svg: '<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M17.71 7.71L12 2h-1v7.59L6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 11 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM13 5.83l1.88 1.88L13 9.59V5.83zm1.88 10.46L13 18.17v-3.76l1.88 1.88z" fill="#d2d2d2"/></svg>',
                isSupported: () => {
                    if (navigator.platform.indexOf("Win") >= 0 &&
                        (navigator.userAgent.indexOf("Chrome/54") >= 0 ||
                            navigator.userAgent.indexOf("Chrome/55") >= 0 ||
                            navigator.userAgent.indexOf("Chrome/56") >= 0))
                        return "Chrome <56 in Windows has navigator.bluetooth but it's not implemented properly";
                    if (window &&
                        window.location &&
                        window.location.protocol == "http:" &&
                        window.location.hostname != "localhost")
                        return "Serving off HTTP (not HTTPS) - Web Bluetooth not enabled";
                    if (navigator.bluetooth)
                        return true;
                    var iOS = (0, isIOS_1.isIOS)();
                    if (iOS) {
                        return "To use Web Bluetooth on iOS you'll need the WebBLE App.\nPlease go to https://itunes.apple.com/us/app/webble/id1193531073 to download it.";
                    }
                    else {
                        return "This Web Browser doesn't support Web Bluetooth.\nPlease see https://www.espruino.com/Puck.js+Quick+Start";
                    }
                },
                connect: (connection, callback) => {
                    var NORDIC_SERVICE = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
                    var NORDIC_TX = "6e400002-b5a3-f393-e0a9-e50e24dcca9e";
                    var NORDIC_RX = "6e400003-b5a3-f393-e0a9-e50e24dcca9e";
                    var DEFAULT_CHUNKSIZE = 20;
                    // FIND OUT CORRECT TYPES FOR THIS
                    var btServer = undefined;
                    var btService;
                    var txCharacteristic;
                    var rxCharacteristic;
                    var txDataQueue = [];
                    var flowControlXOFF = false;
                    var chunkSize = DEFAULT_CHUNKSIZE;
                    connection.close = (callback) => {
                        connection.isOpening = false;
                        if (connection.isOpen) {
                            connection.isOpen = false;
                            connection.emit("close");
                        }
                        else {
                            if (callback)
                                callback(null);
                        }
                        if (btServer) {
                            btServer.disconnect();
                            btServer = undefined;
                            txCharacteristic = undefined;
                            rxCharacteristic = undefined;
                        }
                    };
                    connection.write = (data, callback) => {
                        if (data)
                            txDataQueue.push({
                                data: data,
                                callback: callback,
                                maxLength: data.length,
                            });
                        const writeChunk = () => {
                            if (flowControlXOFF) {
                                // flow control - try again later
                                setTimeout(writeChunk, 50);
                                return;
                            }
                            var chunk;
                            if (!txDataQueue.length) {
                                return;
                            }
                            var txItem = txDataQueue[0];
                            if (txItem.data.length <= chunkSize) {
                                chunk = txItem.data;
                                txItem.data = undefined;
                            }
                            else {
                                chunk = txItem.data.substr(0, chunkSize);
                                txItem.data = txItem.data.substr(chunkSize);
                            }
                            connection.txInProgress = true;
                            __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 2, "Sending " + JSON.stringify(chunk));
                            __classPrivateFieldGet(this, _UARTClass_sentChunks, "f").push(JSON.stringify(chunk));
                            txCharacteristic
                                .writeValue((0, stringArrayBuffer_1.str2ab)(chunk))
                                .then(() => {
                                __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 3, "Sent");
                                if (!txItem.data) {
                                    txDataQueue.shift(); // remove this element
                                    if (txItem.callback)
                                        txItem.callback();
                                }
                                connection.txInProgress = false;
                                writeChunk();
                            })
                                .catch((error) => {
                                __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 1, "SEND ERROR: " + error);
                                txDataQueue = [];
                                connection.close();
                            });
                        };
                        if (connection.isOpen && !connection.txInProgress)
                            writeChunk();
                    };
                    navigator.bluetooth
                        .requestDevice({
                        filters: [
                            { namePrefix: "Puck.js" },
                            { namePrefix: "Pixl.js" },
                            { namePrefix: "MDBT42Q" },
                            { namePrefix: "Bangle" },
                            { namePrefix: "RuuviTag" },
                            { namePrefix: "iTracker" },
                            { namePrefix: "Thingy" },
                            { namePrefix: "Espruino" },
                            { services: [NORDIC_SERVICE] },
                        ],
                        optionalServices: [NORDIC_SERVICE],
                    })
                        .then((device) => {
                        __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 1, "Device Name:       " + device.name);
                        __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 1, "Device ID:         " + device.id);
                        // Was deprecated: Should use getPrimaryServices for this in future
                        //log('BT>  Device UUIDs:      ' + device.uuids.join('\n' + ' '.repeat(21)));
                        device.addEventListener("gattserverdisconnected", () => {
                            __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 1, "Disconnected (gattserverdisconnected)");
                            connection.close();
                        });
                        return device.gatt.connect();
                    })
                        .then((server) => {
                        __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 1, "Connected");
                        btServer = server;
                        return server.getPrimaryService(NORDIC_SERVICE);
                    })
                        .then((service) => {
                        __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 2, "Got service");
                        btService = service;
                        return btService.getCharacteristic(NORDIC_RX);
                    })
                        .then((characteristic) => {
                        rxCharacteristic = characteristic;
                        __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 2, "RX characteristic:" + JSON.stringify(rxCharacteristic));
                        rxCharacteristic.addEventListener("characteristicvaluechanged", (event) => {
                            var dataview = event.target.value;
                            if (dataview.byteLength > chunkSize) {
                                __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 2, "Received packet of length " +
                                    dataview.byteLength +
                                    ", increasing chunk size");
                                chunkSize = dataview.byteLength;
                            }
                            if (__classPrivateFieldGet(this, _UARTClass_flowControl, "f")) {
                                for (var i = 0; i < dataview.byteLength; i++) {
                                    var ch = dataview.getUint8(i);
                                    if (ch == 17) {
                                        // XON
                                        __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 2, "XON received => resume upload");
                                        flowControlXOFF = false;
                                    }
                                    if (ch == 19) {
                                        // XOFF
                                        __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 2, "XOFF received => pause upload");
                                        flowControlXOFF = true;
                                    }
                                }
                            }
                            var str = (0, stringArrayBuffer_1.ab2str)(dataview.buffer);
                            __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 3, "Received " + JSON.stringify(str));
                            connection.emit("data", str);
                        });
                        return rxCharacteristic.startNotifications();
                    })
                        .then(function () {
                        return btService.getCharacteristic(NORDIC_TX);
                    })
                        .then((characteristic) => {
                        txCharacteristic = characteristic;
                        __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 2, "TX characteristic:" + JSON.stringify(txCharacteristic));
                    })
                        .then(() => {
                        connection.txInProgress = false;
                        connection.isOpen = true;
                        connection.isOpening = false;
                        this.isBusy = false;
                        __classPrivateFieldSet(this, _UARTClass_queue, [], "f");
                        callback(connection);
                        connection.emit("open");
                        // if we had any writes queued, do them now
                        connection.write();
                    })
                        .catch((error) => {
                        __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 1, "ERROR: " + error);
                        connection.close();
                    });
                    return connection;
                },
            },
            {
                name: "Web Serial",
                description: "USB connected devices",
                svg: '<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M15 7v4h1v2h-3V5h2l-3-4-3 4h2v8H8v-2.07c.7-.37 1.2-1.08 1.2-1.93 0-1.21-.99-2.2-2.2-2.2-1.21 0-2.2.99-2.2 2.2 0 .85.5 1.56 1.2 1.93V13c0 1.11.89 2 2 2h3v3.05c-.71.37-1.2 1.1-1.2 1.95 0 1.22.99 2.2 2.2 2.2 1.21 0 2.2-.98 2.2-2.2 0-.85-.49-1.58-1.2-1.95V15h3c1.11 0 2-.89 2-2v-2h1V7h-4z" fill="#d2d2d2"/></svg>',
                isSupported: function () {
                    if (!navigator.serial)
                        return "No navigator.serial - Web Serial not enabled";
                    if (window &&
                        window.location &&
                        window.location.protocol == "http:" &&
                        window.location.hostname != "localhost")
                        return "Serving off HTTP (not HTTPS) - Web Serial not enabled";
                    return true;
                },
                connect: (connection, callback) => {
                    var serialPort;
                    const disconnected = () => {
                        connection.isOpening = false;
                        if (connection.isOpen) {
                            __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 1, "Disconnected");
                            connection.isOpen = false;
                            connection.emit("close");
                        }
                    };
                    // TODO: Pass USB vendor and product ID filter when supported by Chrome.
                    navigator.serial
                        .requestPort()
                        .then((port) => {
                        __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 1, "Connecting to serial port");
                        serialPort = port;
                        return port.open({ baudRate: 115200 });
                    })
                        .then(() => {
                        const readLoop = () => {
                            var reader = serialPort.readable.getReader();
                            // FIND OUT CORRECT TYPES FOR THIS
                            reader.read().then(({ value, done }) => {
                                reader.releaseLock();
                                if (value) {
                                    var str = (0, stringArrayBuffer_1.ab2str)(value.buffer);
                                    __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 3, "Received " + JSON.stringify(str));
                                    connection.emit("data", str);
                                }
                                if (done) {
                                    disconnected();
                                }
                                else {
                                    readLoop();
                                }
                            });
                        };
                        readLoop();
                        __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 1, "Serial connected. Receiving data...");
                        connection.txInProgress = false;
                        connection.isOpen = true;
                        connection.isOpening = false;
                        callback(connection);
                    })
                        .catch((error) => {
                        __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 0, "ERROR: " + error);
                        disconnected();
                    });
                    connection.close = function (callback) {
                        if (serialPort) {
                            serialPort.close();
                            serialPort = undefined;
                        }
                        disconnected();
                    };
                    connection.write = (data, callback) => {
                        var writer = serialPort.writable.getWriter();
                        // TODO: progress?
                        writer
                            .write((0, stringArrayBuffer_1.str2ab)(data))
                            .then(() => {
                            callback === null || callback === void 0 ? void 0 : callback(data);
                        })
                            .catch((error) => {
                            __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 0, "SEND ERROR: " + error);
                        });
                        writer.releaseLock();
                    };
                    return connection;
                },
            },
        ]);
        this.DATA_WAIT_TIME = options === null || options === void 0 ? void 0 : options.dataWaitTime;
    }
    connect(callback) {
        __classPrivateFieldSet(this, _UARTClass_connection, {
            on: function (evt, cb) {
                this["on" + evt] = cb;
            },
            emit: function (evt, data) {
                if (this["on" + evt])
                    this["on" + evt](data);
            },
            isOpen: false,
            isOpening: true,
            txInProgress: false,
        }, "f");
        // modal
        var e = document.createElement("div");
        e.setAttribute("style", "position:absolute;top:0px;left:0px;right:0px;bottom:0px;opacity:0.5;z-index:100;background:black;");
        // menu
        var menu = document.createElement("div");
        menu.setAttribute("style", "position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-family: Sans-Serif;z-index:101;");
        var menutitle = document.createElement("div");
        menutitle.classList.add(modal_1.classes.menu);
        var menuContent = document.createElement("div");
        menuContent.classList.add("esp-tools-header-bar");
        let menuTitle = document.createElement("p");
        menuTitle.innerText = "Connect";
        menuContent.appendChild(menuTitle);
        let menuClose = document.createElement("div");
        menuClose.innerHTML =
            '<svg id="esp-tools-close-modal" stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill="none" stroke="#000" stroke-width="2" d="M7,7 L17,17 M7,17 L17,7"></path></svg>';
        menuContent.appendChild(menuClose);
        menutitle.appendChild(menuContent);
        menu.appendChild(menutitle);
        var items = document.createElement("div");
        items.classList.add(modal_1.classes.items);
        let p = document.createElement("p");
        p.innerText = "Select a connection method to pair your device";
        items.appendChild(p);
        menu.appendChild(items);
        __classPrivateFieldGet(this, _UARTClass_endpoints, "f").forEach((endpoint) => {
            var supported = endpoint.isSupported();
            if (supported !== true)
                __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 0, endpoint.name + " not supported, " + supported);
            var ep = document.createElement("div");
            ep.classList.add(modal_1.classes.endpoints);
            ep.innerHTML =
                '<div class="esp-tools-icons">' +
                    endpoint.svg +
                    "</div>" +
                    '<div class="esp-tools-name">' +
                    endpoint.name +
                    "</div>" +
                    '<div class="esp-tools-description">' +
                    endpoint.description +
                    "</div>";
            ep.onclick = (evt) => {
                __classPrivateFieldSet(this, _UARTClass_connection, endpoint.connect(__classPrivateFieldGet(this, _UARTClass_connection, "f"), callback), "f");
                evt.preventDefault();
                document.body.removeChild(menu);
                document.body.removeChild(e);
            };
            items.appendChild(ep);
        });
        menuClose.onclick = () => {
            document.body.removeChild(menu);
            document.body.removeChild(e);
            __classPrivateFieldGet(this, _UARTClass_connection, "f").isOpening = false;
            if (__classPrivateFieldGet(this, _UARTClass_connection, "f").isOpen) {
                __classPrivateFieldGet(this, _UARTClass_connection, "f").isOpen = false;
            }
            else {
                if (callback)
                    callback(null);
            }
        };
        document.body.appendChild(e);
        document.body.appendChild(menu);
        return __classPrivateFieldGet(this, _UARTClass_connection, "f");
    }
    getWrittenData() {
        let str_chunks = __classPrivateFieldGet(this, _UARTClass_sentChunks, "f").join("");
        return new Promise((resolve) => resolve(str_chunks));
    }
    write(data, callback, callbackNewline) {
        if (!__classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_checkIfSupported).call(this))
            return;
        if (this.isBusy) {
            __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 3, "Busy - adding write to queue");
            __classPrivateFieldGet(this, _UARTClass_queue, "f").push({
                type: "write",
                data: data,
                callback: callback,
                callbackNewline: callbackNewline,
            });
            return;
        }
        var cbTimeout;
        const onWritten = () => {
            if (callbackNewline) {
                __classPrivateFieldGet(this, _UARTClass_connection, "f").cb = () => {
                    var newLineIdx = __classPrivateFieldGet(this, _UARTClass_connection, "f").received.indexOf("\n");
                    if (newLineIdx >= 0) {
                        var l = __classPrivateFieldGet(this, _UARTClass_connection, "f").received.substr(0, newLineIdx);
                        __classPrivateFieldGet(this, _UARTClass_connection, "f").received = __classPrivateFieldGet(this, _UARTClass_connection, "f").received.substr(newLineIdx + 1);
                        __classPrivateFieldGet(this, _UARTClass_connection, "f").cb = undefined;
                        if (cbTimeout)
                            clearTimeout(cbTimeout);
                        cbTimeout = undefined;
                        if (callback)
                            callback(l);
                        this.isBusy = false;
                        __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_handleQueue).call(this);
                    }
                };
            }
            // wait for any received data if we have a callback...
            var maxTime = 300; // 30 sec - Max time we wait in total, even if getting data
            var dataWaitTime = callbackNewline
                ? 100 /*10 sec  if waiting for newline*/
                : 0; /*300ms*/
            var maxDataTime = dataWaitTime; // max time we wait after having received data
            const timeout = () => {
                cbTimeout = undefined;
                if (maxTime)
                    maxTime--;
                if (maxDataTime)
                    maxDataTime--;
                if (__classPrivateFieldGet(this, _UARTClass_connection, "f").hadData)
                    maxDataTime = dataWaitTime;
                if (maxDataTime && maxTime) {
                    cbTimeout = setTimeout(timeout, 100);
                }
                else {
                    __classPrivateFieldGet(this, _UARTClass_connection, "f").cb = undefined;
                    if (callbackNewline)
                        __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 2, "write waiting for newline timed out");
                    if (callback)
                        callback(__classPrivateFieldGet(this, _UARTClass_connection, "f").received);
                    this.isBusy = false;
                    __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_handleQueue).call(this);
                    __classPrivateFieldGet(this, _UARTClass_connection, "f").received = "";
                }
                __classPrivateFieldGet(this, _UARTClass_connection, "f").hadData = false;
            };
            cbTimeout = setTimeout(timeout, 100);
        };
        if (__classPrivateFieldGet(this, _UARTClass_connection, "f") &&
            (__classPrivateFieldGet(this, _UARTClass_connection, "f").isOpen || __classPrivateFieldGet(this, _UARTClass_connection, "f").isOpening)) {
            if (!__classPrivateFieldGet(this, _UARTClass_connection, "f").txInProgress)
                __classPrivateFieldGet(this, _UARTClass_connection, "f").received = "";
            this.isBusy = true;
            return __classPrivateFieldGet(this, _UARTClass_connection, "f").write(data, onWritten);
        }
        __classPrivateFieldSet(this, _UARTClass_connection, this.connect((uart) => {
            if (!uart) {
                __classPrivateFieldSet(this, _UARTClass_connection, undefined, "f");
                if (callback)
                    callback(null);
                return;
            }
            __classPrivateFieldGet(this, _UARTClass_connection, "f").received = "";
            __classPrivateFieldGet(this, _UARTClass_connection, "f").on("data", (d) => {
                __classPrivateFieldGet(this, _UARTClass_connection, "f").received += d;
                __classPrivateFieldGet(this, _UARTClass_connection, "f").hadData = true;
                if (__classPrivateFieldGet(this, _UARTClass_connection, "f").cb)
                    __classPrivateFieldGet(this, _UARTClass_connection, "f").cb(d);
            });
            __classPrivateFieldGet(this, _UARTClass_connection, "f").on("close", (d) => {
                __classPrivateFieldSet(this, _UARTClass_connection, undefined, "f");
            });
            this.isBusy = true;
            __classPrivateFieldGet(this, _UARTClass_connection, "f").write(data, onWritten);
        }), "f");
    }
    eval(expr, cb) {
        if (!__classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_checkIfSupported).call(this))
            return false;
        if (this.isBusy) {
            __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 3, "Busy - adding eval to queue");
            __classPrivateFieldGet(this, _UARTClass_queue, "f").push({ type: "eval", expr: expr, cb: cb });
            return false;
        }
        this.write("\x10eval(process.env.CONSOLE).println(JSON.stringify(" + expr + "))\n", (d) => {
            try {
                var json = JSON.parse(d.trim());
                cb(json, "success");
            }
            catch (e) {
                __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 1, "Unable to decode " + JSON.stringify(d) + ", got " + e.toString());
                cb(null, "failed");
            }
        }, true /*callbackNewline*/);
        return true;
    }
    setTime(cb) {
        let d = new Date();
        let cmd = "setTime(" + d.getTime() / 1000 + ");";
        cmd +=
            "if (E.setTimeZone) E.setTimeZone(" +
                d.getTimezoneOffset() / -60 +
                ");\n";
        this.write(cmd, cb);
    }
    isConnected() {
        return __classPrivateFieldGet(this, _UARTClass_connection, "f") !== undefined;
    }
    getConnection() {
        return __classPrivateFieldGet(this, _UARTClass_connection, "f");
    }
    close() {
        if (__classPrivateFieldGet(this, _UARTClass_connection, "f"))
            __classPrivateFieldGet(this, _UARTClass_connection, "f").close();
    }
}
_UARTClass_debug = new WeakMap(), _UARTClass_flowControl = new WeakMap(), _UARTClass_queue = new WeakMap(), _UARTClass_sentChunks = new WeakMap(), _UARTClass_connection = new WeakMap(), _UARTClass_endpoints = new WeakMap(), _UARTClass_instances = new WeakSet(), _UARTClass_handleQueue = function _UARTClass_handleQueue() {
    if (!__classPrivateFieldGet(this, _UARTClass_queue, "f").length)
        return;
    var q = __classPrivateFieldGet(this, _UARTClass_queue, "f").shift();
    __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 3, "Executing " + JSON.stringify(q) + " from queue");
    if (q.type == "eval")
        this.eval(q.expr, q.cb);
    else if (q.type == "write")
        this.write(q.data, q.callback, q.callbackNewline);
    else
        __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 1, "Unknown queue item " + JSON.stringify(q));
}, _UARTClass_log = function _UARTClass_log(level, s) {
    level <= __classPrivateFieldGet(this, _UARTClass_debug, "f") && console.log("<UART> " + s);
}, _UARTClass_checkIfSupported = function _UARTClass_checkIfSupported() {
    var anySupported = false;
    __classPrivateFieldGet(this, _UARTClass_endpoints, "f").forEach((endpoint) => {
        var supported = endpoint.isSupported();
        if (supported === true)
            anySupported = true;
        else
            __classPrivateFieldGet(this, _UARTClass_instances, "m", _UARTClass_log).call(this, 0, endpoint.name + " not supported, " + supported);
    });
    return anySupported;
};
let uart = new UARTClass();
exports.uart = uart;
