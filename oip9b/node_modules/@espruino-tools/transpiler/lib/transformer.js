"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformer = void 0;
const mappings_1 = require("./mappings");
const esprima = require("esprima");
const generator_1 = require("./generator");
/**
 * This will replace code in AST pre-rebuilding
 * @param ast
 */
const transformer = (ast, options) => {
    let callee_names = [
        'Puck',
        'Pixl',
        'Bangle',
        'DeviceController',
        ...(options.additional_initialisers
            ? options.additional_initialisers
            : []),
    ];
    const getInstanceInitialising = (ast) => {
        let variable_declarations = ast.body.filter((x) => x.type == 'VariableDeclaration');
        let esp_inititalising_vars = variable_declarations.filter((x) => { var _a; return callee_names.includes((_a = x.declarations[0].init.callee) === null || _a === void 0 ? void 0 : _a.name); });
        let callees = [
            ...esp_inititalising_vars.map((x) => ({
                name: x.declarations[0].id.name,
                initialiser: x.declarations[0].init.callee.name,
            })),
            ...options.additional_callees,
        ];
        return callees;
    };
    const convertToAST = (code, params) => {
        let code_arr = code.split('.');
        let expression_func = code_arr.reduce((prev, curr) => prev[curr], mappings_1.mappings);
        return esprima.parseScript(expression_func(...params)).body[0];
    };
    const replaceReturnedExpression = (x) => {
        var _a, _b, _c, _d, _e, _f;
        if ((x === null || x === void 0 ? void 0 : x.type) === 'Identifier') {
            return x;
        }
        let esp_initialising_vars = getInstanceInitialising(ast);
        let device_variable = (_c = (_b = (_a = x === null || x === void 0 ? void 0 : x.callee) === null || _a === void 0 ? void 0 : _a.object) === null || _b === void 0 ? void 0 : _b.object) === null || _c === void 0 ? void 0 : _c.name;
        let device_init = esp_initialising_vars.find((x) => x.name === device_variable);
        let phrase = device_init.initialiser + '.';
        if ((_d = x.callee.object.property) === null || _d === void 0 ? void 0 : _d.name) {
            phrase +=
                ((_e = x.callee.object.property) === null || _e === void 0 ? void 0 : _e.name) && ((_f = x.callee.object.property) === null || _f === void 0 ? void 0 : _f.name) + '.';
        }
        let params = x.arguments.map((y) => {
            if (y.hasOwnProperty('value')) {
                return y.value;
            }
            else {
                let transformer_out = (0, exports.transformer)(x.body, {
                    additional_callees: getInstanceInitialising(ast),
                });
                return (0, generator_1.generator)(transformer_out, {
                    additional_callees: [],
                });
            }
        });
        phrase += x.callee.property.name;
        let ast_res = convertToAST(phrase, params);
        return ast_res;
    };
    const replaceExpression = (x) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        let esp_initialising_vars = getInstanceInitialising(ast);
        let device_variable;
        switch (x === null || x === void 0 ? void 0 : x.type) {
            case 'IfStatement': {
                return replaceIfStatement(x);
            }
            case 'ClassDeclaration':
                return replaceClass(x);
            case 'FunctionDeclaration':
            case 'WhileStatement':
            case 'ForStatement':
            case 'ForInStatement':
            case 'DoWhileStatement': {
                return replaceLoopStatement(x);
            }
            case 'SwitchStatement':
                return replaceSwitchStatement(x);
            case 'ContinueStatement':
            case 'BreakStatement':
                return x;
        }
        if ((x === null || x === void 0 ? void 0 : x.type) === 'VariableDeclaration') {
            if (((_a = x.declarations[0].init) === null || _a === void 0 ? void 0 : _a.type) === 'FunctionExpression') {
                x.declarations[0].init.body.body = x.declarations[0].init.body.body.map((y) => replaceExpression(y));
            }
            if (((_b = x.declarations[0].init) === null || _b === void 0 ? void 0 : _b.type) === 'AwaitExpression') {
                return x;
            }
            if (((_c = x.declarations[0].init) === null || _c === void 0 ? void 0 : _c.type) === 'ObjectExpression') {
                x.declarations[0].init.properties =
                    x.declarations[0].init.properties.map((y) => {
                        if (y.value.type === 'FunctionExpression') {
                            y.value = replaceLoopStatement(y.value);
                        }
                        else if (y.value.type === 'CallExpression') {
                            y.value = replaceReturnedExpression(y.value);
                        }
                        else if (x.value.type === 'ArrowFunctionExpression') {
                            y.value.body = replaceReturnedExpression(y.value.body);
                        }
                        return y;
                    });
                return x;
            }
        }
        if ((x === null || x === void 0 ? void 0 : x.type) === 'ReturnStatement') {
            if (x.argument.type === 'Literal') {
                return x;
            }
            x.argument = replaceReturnedExpression(x.argument);
            return x;
        }
        if ((x === null || x === void 0 ? void 0 : x.expression.type) === 'LogicalExpression') {
            if (x.expression.right.type !== 'Literal') {
                x.expression.right = replaceReturnedExpression(x.expression.right);
            }
            if (x.expression.left.type !== 'Literal') {
                x.expression.left = replaceReturnedExpression(x.expression.left);
            }
            return x;
        }
        if ((x === null || x === void 0 ? void 0 : x.expression.type) === 'ConditionalExpression') {
            x.expression.consequent = replaceReturnedExpression(x.expression.consequent);
            x.expression.alternate = replaceReturnedExpression(x.expression.alternate);
            return x;
        }
        if ((x === null || x === void 0 ? void 0 : x.expression.type) === 'AssignmentExpression') {
            return x;
        }
        if (((_e = (_d = x === null || x === void 0 ? void 0 : x.expression) === null || _d === void 0 ? void 0 : _d.callee) === null || _e === void 0 ? void 0 : _e.object.type) === 'MemberExpression') {
            device_variable = x.expression.callee.object.object.name;
        }
        else if (((_h = (_g = (_f = x === null || x === void 0 ? void 0 : x.expression) === null || _f === void 0 ? void 0 : _f.callee) === null || _g === void 0 ? void 0 : _g.object) === null || _h === void 0 ? void 0 : _h.type) === 'Identifier') {
            device_variable = x.expression.callee.object.name;
        }
        else {
            device_variable = '';
        }
        if (((_k = (_j = x === null || x === void 0 ? void 0 : x.expression) === null || _j === void 0 ? void 0 : _j.object) === null || _k === void 0 ? void 0 : _k.type) === 'ThisExpression') {
            return x;
        }
        if (!esp_initialising_vars.map((x) => x.name).includes(device_variable)) {
            if ((x === null || x === void 0 ? void 0 : x.expression.arguments) instanceof Array) {
                x.expression.arguments = x.expression.arguments.map((y) => {
                    if (y.hasOwnProperty('value')) {
                        return y.value;
                    }
                    else {
                        if (y.body.hasOwnProperty('body')) {
                            y.body.body = y.body.body.map((z) => replaceExpression(z));
                        }
                        return y;
                    }
                });
            }
            return x;
        }
        else {
            let device_init = esp_initialising_vars.find((x) => x.name === device_variable);
            let phrase = device_init.initialiser + '.';
            if ((_l = x.expression.callee.object.property) === null || _l === void 0 ? void 0 : _l.name) {
                phrase +=
                    ((_m = x.expression.callee.object.property) === null || _m === void 0 ? void 0 : _m.name) &&
                        ((_o = x.expression.callee.object.property) === null || _o === void 0 ? void 0 : _o.name) + '.';
            }
            let params = x.expression.arguments.map((x) => {
                if (x.hasOwnProperty('value')) {
                    return x.value;
                }
                else {
                    let transformer_out = (0, exports.transformer)(x.body, {
                        additional_callees: getInstanceInitialising(ast),
                    });
                    return (0, generator_1.generator)(transformer_out, {
                        additional_callees: [],
                    });
                }
            });
            phrase += x.expression.callee.property.name;
            let ast_res = convertToAST(phrase, params);
            return ast_res;
        }
    };
    const removeInitsAndImports = (ast) => {
        var _a, _b, _c, _d;
        let val;
        switch (ast.type) {
            case 'ImportDeclaration': {
                val = ast.source.value.includes('espruino-tools') ? '' : ast;
                break;
            }
            case 'VariableDeclaration': {
                if (((_a = ast.declarations[0].init) === null || _a === void 0 ? void 0 : _a.type) === 'FunctionExpression') {
                    ast.declarations[0].init.body.body =
                        ast.declarations[0].init.body.body.map((x) => replaceExpression(x));
                }
                if (((_b = ast.declarations[0].init) === null || _b === void 0 ? void 0 : _b.type) === 'ObjectExpression') {
                    ast.declarations[0].init.properties =
                        ast.declarations[0].init.properties.map((x) => {
                            if (x.value.type === 'FunctionExpression') {
                                x.value = replaceLoopStatement(x.value);
                            }
                            else if (x.value.type === 'CallExpression') {
                                x.value = replaceReturnedExpression(x.value);
                            }
                            else if (x.value.type === 'ArrowFunctionExpression') {
                                x.value.body = replaceReturnedExpression(x.value.body);
                            }
                            return x;
                        });
                }
                if (((_c = ast.declarations[0].init) === null || _c === void 0 ? void 0 : _c.type) === 'ArrowFunctionExpression') {
                    if (ast.declarations[0].init.body.body instanceof Array) {
                        ast.declarations[0].init.body.body =
                            ast.declarations[0].init.body.body.map((x) => replaceExpression(x));
                    }
                    else {
                        ast.declarations[0].init.body = replaceReturnedExpression(ast.declarations[0].init.body);
                    }
                }
                if (ast.declarations[0].init.hasOwnProperty('callee')) {
                    val = callee_names.includes((_d = ast.declarations[0].init.callee) === null || _d === void 0 ? void 0 : _d.name)
                        ? ''
                        : ast;
                }
                else {
                    val = ast;
                }
                break;
            }
            default:
                return ast;
        }
        return val;
    };
    const replaceIfExpressions = (x) => {
        let x_copy = Object.assign({}, x);
        if (x_copy.type === 'BlockStatement') {
            x_copy.body = x_copy.body.map((y) => replaceExpression(y));
        }
        if (x_copy.type === 'IfStatement') {
            return replaceIfStatement(x_copy);
        }
        return x_copy;
    };
    const replaceIfStatement = (x) => {
        let if_copy = Object.assign({}, x);
        if_copy.consequent = replaceIfExpressions(x.consequent);
        if (if_copy.alternate) {
            if_copy.alternate = replaceIfExpressions(x.alternate);
        }
        return if_copy;
    };
    const replaceLoopStatement = (x) => {
        let loop_copy = Object.assign({}, x);
        loop_copy.body.body = loop_copy.body.body.map((y) => replaceExpression(y));
        return loop_copy;
    };
    const replaceSwitchStatement = (x) => {
        let switch_copy = Object.assign({}, x);
        switch_copy.cases = switch_copy.cases.map((y) => (y.consequent = y.consequent.map((z) => replaceExpression(z))));
        return x;
    };
    const replaceClass = (x) => {
        let class_copy = Object.assign({}, x);
        class_copy.body.body = class_copy.body.body.map((y) => {
            y.value = replaceLoopStatement(y.value);
            return y;
        });
        return class_copy;
    };
    const replaceTryCatch = (x) => {
        x.block.body = x.block.body.map((y) => {
            return replaceExpression(y);
        });
        x.handler.body.body = x.handler.body.body.map((y) => {
            return replaceExpression(y);
        });
        return x;
    };
    const getExpressions = (ast) => {
        let ast_copy = Object.assign({}, ast);
        ast_copy.body = ast.body
            .map((x) => {
            switch (x.type) {
                case 'ExpressionStatement': {
                    return replaceExpression(x);
                }
                case 'TryStatement': {
                    return replaceTryCatch(x);
                }
                case 'IfStatement': {
                    return replaceIfStatement(x);
                }
                case 'ClassDeclaration':
                    return replaceClass(x);
                case 'FunctionDeclaration':
                case 'WhileStatement':
                case 'ForStatement':
                case 'ForInStatement':
                case 'AsyncFunctionDeclaration':
                case 'DoWhileStatement': {
                    return replaceLoopStatement(x);
                }
                case 'SwitchStatement':
                    return replaceSwitchStatement(x);
                default: {
                    return removeInitsAndImports(x);
                }
            }
        })
            .filter((x) => x !== '');
        return ast_copy;
    };
    return getExpressions(ast);
};
exports.transformer = transformer;
