"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Puck = void 0;
const transpiler_1 = require("@espruino-tools/transpiler");
const device_controller_1 = require("./device-controller");
const puck_types_1 = require("./types/puck-types");
class Puck extends device_controller_1.DeviceController {
    constructor() {
        super(...arguments);
        this.mag = {
            enableMag: () => {
                this.UART.write('Puck.magOn();\n');
            },
            enableField: () => {
                this.UART.write('require("puckjsv2-mag-level").on();\n');
            },
            disableMag: () => {
                this.UART.write('Puck.magOff();\n');
            },
            disableField: () => {
                this.UART.write('require("puckjsv2-mag-level").off();\n');
            },
            onMag: (func) => {
                let transpiled_code = (0, transpiler_1.transpile)(`p.mag.onMag(${func.toString()})`, {
                    additional_callees: ['p'],
                    parse_type: 'module',
                });
                this.UART.write(transpiled_code);
            },
            onField: (func) => {
                let transpiled_code = (0, transpiler_1.transpile)(`p.mag.onField(${func.toString()})`, {
                    additional_callees: ['p'],
                    parse_type: 'module',
                });
                this.UART.write(transpiled_code);
            },
        };
        this.accel = {
            enableAccelMovement: () => {
                this.UART.write('require("puckjsv2-accel-movement").on();\n');
            },
            enableAccelBigMovement: () => {
                this.UART.write('require("puckjsv2-accel-bigmovement").on();\n');
            },
            enableAccelTilt: () => {
                this.UART.write('require("puckjsv2-accel-tilt").on();\n');
            },
            disableAccelMovement: () => {
                this.UART.write('require("puckjsv2-accel-movement").off();\n');
            },
            disableAccelBigMovement: () => {
                this.UART.write('require("puckjsv2-accel-bigmovement").off();\n');
            },
            disableAccelTilt: () => {
                this.UART.write('require("puckjsv2-accel-tilt").off();\n');
            },
            val: () => {
                return this.eval('Puck.accel()');
            },
            onMove: (func) => {
                let transpiled_code = (0, transpiler_1.transpile)(`p.accel.onMove(${func.toString()})`, {
                    additional_callees: ['p'],
                    parse_type: 'module',
                });
                this.UART.write(transpiled_code);
            },
            onTilt: (func) => {
                let transpiled_code = (0, transpiler_1.transpile)(`p.accel.onTilt(${func.toString()})`, {
                    additional_callees: ['p'],
                    parse_type: 'module',
                });
                this.UART.write(transpiled_code);
            },
        };
        this.IR = {
            transmit: (data) => {
                this.UART.write('Puck.IR([' + data.join(',') + ']);\n');
            },
        };
        this.LED = {
            /**
             *
             * @param color LED Colour to be turned on
             */
            on: (color) => {
                Array.isArray(color)
                    ? this.UART.write(`digitalWrite(${color}, 1)`)
                    : this.UART.write(`LED${puck_types_1.LEDColours.indexOf(color) + 1}.set();\n`);
            },
            /**
             *
             * @param color LED Colour to be turned off
             */
            off: (color) => {
                Array.isArray(color)
                    ? this.UART.write(`digitalWrite(${color}, 0)`)
                    : this.UART.write(`LED${puck_types_1.LEDColours.indexOf(color) + 1}.reset();\n`);
            },
            /**
             *
             * @param color LED Colour to be toggled
             */
            toggle: (color) => {
                this.UART.write(`LED${puck_types_1.LEDColours.indexOf(color) + 1}.toggle();\n`);
            },
            /**
             *
             * @param color LED Colour to be flashed
             * @param ms time for LED to be flashed
             */
            flash: (color, ms) => {
                this.UART.write(`digitalPulse(LED${puck_types_1.LEDColours.indexOf(color) + 1},1,${ms});\n`);
            },
            /**
             *
             * @param color LED colour to grab info from
             * @returns a boolean regarding if the LED is on or off
             */
            val: (color) => {
                return this.eval(`digitalRead(LED${puck_types_1.LEDColours.indexOf(color) + 1}) == 1`);
            },
        };
        this.NFC = {
            /**
             *
             * @param url the url to be used as the new NFC value
             */
            setUrl: (url) => this.UART.write('NRF.nfcURL("' + url + '");\n'),
            reset: () => this.UART.write('NRF.nfcURL();\n'),
        };
    }
    /**
     *
     * @returns a promise containing the light value detected by the puck device.
     */
    getLightVal() {
        return this.eval('Puck.light()');
    }
    /**
     *
     * @returns temperature from device
     */
    getTemperature() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.eval(`E.getTemperature()`);
        });
    }
    /**
     *
     * @param func A function to be run of press of pucks button
     */
    onPress(func) {
        let transpiled_code = (0, transpiler_1.transpile)(`p.onTimedPress(${func.toString()})`, {
            additional_callees: ['p'],
            parse_type: 'module',
        });
        this.UART.write(transpiled_code);
    }
    /**
     *
     * @param long The function to be called on a long press
     * @param short The function to be called on a short press
     * @param ms the time required to consider a press a long press
     */
    onTimedPress(long, short, ms = 0.3) {
        let transpiled_code = (0, transpiler_1.transpile)(`p.onTimedPress(${long.toString()},${short.toString()},${ms})`, {
            additional_callees: ['p'],
            parse_type: 'module',
        });
        this.UART.write(transpiled_code);
    }
}
exports.Puck = Puck;
