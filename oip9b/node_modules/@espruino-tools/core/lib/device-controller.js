"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DeviceController_instances, _DeviceController_mapStringFunctionToCall, _DeviceController_getFunctionNamesFromString;
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeviceController = void 0;
const transpiler_1 = require("@espruino-tools/transpiler");
const uart_1 = require("@espruino-tools/uart");
const fetchHelper_1 = require("./helpers/fetchHelper");
class DeviceController {
    constructor() {
        _DeviceController_instances.add(this);
        this.connected = false;
        this.UART = uart_1.uart;
        this.deviceType = undefined;
        /**
         * An object holding any functions on the device
         */
        this.Call = {};
        /**
         * An Object containing all pin methods
         */
        this.Pin = {
            /**
             *
             * @param pin the pin to have its value returned
             * @returns current value of chosen pin
             */
            val: (pin) => this.eval(pin + '.read()'),
            /**
             *
             * @param pin the pin to have its analog value changed
             * @param val should be between 0 and 1, e.g. 0.5
             */
            analogOn: (pin, val) => this.UART.write('analogWrite(' + pin + ',' + val + ');\n'),
            /**
             *
             * @param pin the pin to have its digital value changed
             * @param val can be either 0 or 1 for off or on
             */
            digitalOn: (pin, val) => this.UART.write('digitalWrite(' + pin + ',' + val + ');\n'),
            /**
             *
             * @param pin the pin to be toggled
             */
            digitalToggle: (pin) => this.UART.write(pin + '.toggle();\n'),
            /**
             *
             * @param pin the pin to be reset
             */
            reset: (pin) => this.UART.write(pin + '.reset();\n'),
            /**
             *
             * @param pin the pin to gather information from
             * @returns a promise containing pin info
             */
            getInfo: (pin) => this.eval(pin + '.getInfo()'),
        };
    }
    /**
     *
     * @returns  promise containing all code stored on device
     */
    dump() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.eval('E.dumpStr()');
        });
    }
    /**
     *
     * @returns device type of connected device
     */
    getDeviceType() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.eval(`process.env.BOARD`);
        });
    }
    /**
     *
     * @returns battery percentage of the connected device
     */
    getBattery() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.eval(`E.getBattery()`);
        });
    }
    /**
     *
     * @param code code to be evaluated
     * @returns the response from the device in a Promise
     */
    eval(code) {
        return __awaiter(this, void 0, void 0, function* () {
            const p = new Promise((resolve) => {
                let callback = (data, log) => {
                    if (!log)
                        log = '';
                    resolve({ data, log });
                };
                this.UART.eval(code, callback);
            }).catch((err) => {
                throw new Error(err);
            });
            return p;
        });
    }
    /**
     *
     * @param callback the function to be run after connect
     */
    connect(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.eval('{}').then(({ data, log }) => {
                if (log == 'success') {
                    this.connected = true;
                    this.UART.write('digitalPulse(LED2,1,100);\n');
                    this.getDeviceFunctions().then(() => {
                        callback === null || callback === void 0 ? void 0 : callback();
                    });
                }
            });
        });
    }
    /**
     *
     * @param callback the function to be run after disconnect
     */
    disconnect(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.eval('digitalPulse(LED1,1,100);\n').then(() => {
                var _a;
                (_a = this.UART) === null || _a === void 0 ? void 0 : _a.close();
                this.connected = false;
                this.deviceType = undefined;
                callback === null || callback === void 0 ? void 0 : callback();
            });
        });
    }
    /**
     * Clears any saved data on device.
     */
    reset() {
        this.UART.write('reset(true);\n');
    }
    /**
     *
     * > **WARNING**  THIS CODE DOES NO CHECKS AND IS ONLY AVAILABLE FOR SPEED
     *                PURPOSES.
     *
     *                THIS SHOULD BE USED EXCLUSIVELY FOR WHEN CODE DOESNT NEED
     *                TO BE SAVED OR YOU ALREADY KNOW THE METHODS AVAILABLE
     *
     * @param data code written in espruino native code NOT IN THIS LIBRARIES CODE
     */
    quickWrite(data) {
        this.UART.write(data);
    }
    /**
     *
     * @param code code written in espruino native code, NOT IN THIS LIBRARIES CODE
     * @param flash
     */
    loadCode(code, flash = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let deviceType = yield this.getDeviceType();
            if (deviceType === 'BANGLEJS') {
                flash = false;
            }
            let success = false;
            this.reset();
            if (!flash && !success) {
                this.UART.write(code);
            }
            else if (!success && deviceType !== 'PIXLJS') {
                this.UART.write(`E.setBootCode(\`${code}\`,true);\n`);
                this.UART.write('load();\n');
            }
            else if (!success) {
                this.UART.write(code);
                this.UART.write('save();\n');
                this.UART.write('load();\n');
            }
            this.getDeviceFunctions();
        });
    }
    setInterval(func, ms = 2000) {
        let transpiled_code = (0, transpiler_1.transpile)(`DeviceController.setInterval(${func.toString()}, ${ms})`, {
            additional_callees: ['p'],
            parse_type: 'module',
        });
        this.UART.write(transpiled_code);
    }
    /**
     *
     * @param url the url to grab data from
     * @param flash
     */
    upload(url, flash = false) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, fetchHelper_1.fetchToText)(url).then((rawCode) => __awaiter(this, void 0, void 0, function* () {
                this.loadCode(rawCode, flash);
            }));
        });
    }
    /**
     * helper function to grab functions from device
     */
    getDeviceFunctions() {
        return __awaiter(this, void 0, void 0, function* () {
            this.Call = yield this.dump().then((dumpedStr) => {
                __classPrivateFieldGet(this, _DeviceController_instances, "m", _DeviceController_mapStringFunctionToCall).call(this, __classPrivateFieldGet(this, _DeviceController_instances, "m", _DeviceController_getFunctionNamesFromString).call(this, dumpedStr.data));
            });
        });
    }
}
exports.DeviceController = DeviceController;
_DeviceController_instances = new WeakSet(), _DeviceController_mapStringFunctionToCall = function _DeviceController_mapStringFunctionToCall(funcArr) {
    funcArr.map((func) => {
        /*
          This anonymous function converts the array of function data into a digestible callable javascript object
          in notation function_name : function(param1,...){}
          It then
        */
        this.Call = Object.assign({ [func.name]: (...args) => {
                this.UART.write(`${func.name}(${JSON.stringify(args.join(','))});\n`);
            } }, this.Call);
    });
}, _DeviceController_getFunctionNamesFromString = function _DeviceController_getFunctionNamesFromString(str) {
    let str_arr = str.split('\n');
    let new_arr = str_arr.map((x) => {
        if (x.startsWith('function')) {
            return x.split('{')[0].replace('function', '').split(' ').join('');
        }
        else if (x.startsWith('let') || x.startsWith('const')) {
            if (x.includes('function(') || x.includes('=>')) {
                if (x.includes('=>')) {
                    return x
                        .split('=>')[0]
                        .replace('let', '')
                        .replace('const', '')
                        .replace('=', '')
                        .split(' ')
                        .join('');
                }
                else {
                    return x
                        .split('{')[0]
                        .replace('let', '')
                        .replace('const', '')
                        .replace('=', '')
                        .replace('function', '')
                        .split(' ')
                        .join('');
                }
            }
        }
    });
    let filtered_arr = new_arr.filter(Boolean);
    return filtered_arr.map((func) => {
        return {
            name: func.split('(')[0],
            parameters: func.split('(')[1].replace(')', '').split(',')[0] !== ''
                ? func.split('(')[1].replace(')', '').split(',')
                : [],
        };
    });
};
