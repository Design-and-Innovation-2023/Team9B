{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transformer = void 0;\nconst mappings_1 = require(\"./mappings\");\nconst esprima = require(\"esprima\");\nconst generator_1 = require(\"./generator\");\n/**\n * This will replace code in AST pre-rebuilding\n * @param ast\n */\nconst transformer = (ast, options) => {\n  let callee_names = ['Puck', 'Pixl', 'Bangle', 'DeviceController', ...(options.additional_initialisers ? options.additional_initialisers : [])];\n  const getInstanceInitialising = ast => {\n    let variable_declarations = ast.body.filter(x => x.type == 'VariableDeclaration');\n    let esp_inititalising_vars = variable_declarations.filter(x => {\n      var _a;\n      return callee_names.includes((_a = x.declarations[0].init.callee) === null || _a === void 0 ? void 0 : _a.name);\n    });\n    let callees = [...esp_inititalising_vars.map(x => ({\n      name: x.declarations[0].id.name,\n      initialiser: x.declarations[0].init.callee.name\n    })), ...options.additional_callees];\n    return callees;\n  };\n  const convertToAST = (code, params) => {\n    let code_arr = code.split('.');\n    let expression_func = code_arr.reduce((prev, curr) => prev[curr], mappings_1.mappings);\n    return esprima.parseScript(expression_func(...params)).body[0];\n  };\n  const replaceReturnedExpression = x => {\n    var _a, _b, _c, _d, _e, _f;\n    if ((x === null || x === void 0 ? void 0 : x.type) === 'Identifier') {\n      return x;\n    }\n    let esp_initialising_vars = getInstanceInitialising(ast);\n    let device_variable = (_c = (_b = (_a = x === null || x === void 0 ? void 0 : x.callee) === null || _a === void 0 ? void 0 : _a.object) === null || _b === void 0 ? void 0 : _b.object) === null || _c === void 0 ? void 0 : _c.name;\n    let device_init = esp_initialising_vars.find(x => x.name === device_variable);\n    let phrase = device_init.initialiser + '.';\n    if ((_d = x.callee.object.property) === null || _d === void 0 ? void 0 : _d.name) {\n      phrase += ((_e = x.callee.object.property) === null || _e === void 0 ? void 0 : _e.name) && ((_f = x.callee.object.property) === null || _f === void 0 ? void 0 : _f.name) + '.';\n    }\n    let params = x.arguments.map(y => {\n      if (y.hasOwnProperty('value')) {\n        return y.value;\n      } else {\n        let transformer_out = (0, exports.transformer)(x.body, {\n          additional_callees: getInstanceInitialising(ast)\n        });\n        return (0, generator_1.generator)(transformer_out, {\n          additional_callees: []\n        });\n      }\n    });\n    phrase += x.callee.property.name;\n    let ast_res = convertToAST(phrase, params);\n    return ast_res;\n  };\n  const replaceExpression = x => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;\n    let esp_initialising_vars = getInstanceInitialising(ast);\n    let device_variable;\n    switch (x === null || x === void 0 ? void 0 : x.type) {\n      case 'IfStatement':\n        {\n          return replaceIfStatement(x);\n        }\n      case 'ClassDeclaration':\n        return replaceClass(x);\n      case 'FunctionDeclaration':\n      case 'WhileStatement':\n      case 'ForStatement':\n      case 'ForInStatement':\n      case 'DoWhileStatement':\n        {\n          return replaceLoopStatement(x);\n        }\n      case 'SwitchStatement':\n        return replaceSwitchStatement(x);\n      case 'ContinueStatement':\n      case 'BreakStatement':\n        return x;\n    }\n    if ((x === null || x === void 0 ? void 0 : x.type) === 'VariableDeclaration') {\n      if (((_a = x.declarations[0].init) === null || _a === void 0 ? void 0 : _a.type) === 'FunctionExpression') {\n        x.declarations[0].init.body.body = x.declarations[0].init.body.body.map(y => replaceExpression(y));\n      }\n      if (((_b = x.declarations[0].init) === null || _b === void 0 ? void 0 : _b.type) === 'AwaitExpression') {\n        return x;\n      }\n      if (((_c = x.declarations[0].init) === null || _c === void 0 ? void 0 : _c.type) === 'ObjectExpression') {\n        x.declarations[0].init.properties = x.declarations[0].init.properties.map(y => {\n          if (y.value.type === 'FunctionExpression') {\n            y.value = replaceLoopStatement(y.value);\n          } else if (y.value.type === 'CallExpression') {\n            y.value = replaceReturnedExpression(y.value);\n          } else if (x.value.type === 'ArrowFunctionExpression') {\n            y.value.body = replaceReturnedExpression(y.value.body);\n          }\n          return y;\n        });\n        return x;\n      }\n    }\n    if ((x === null || x === void 0 ? void 0 : x.type) === 'ReturnStatement') {\n      if (x.argument.type === 'Literal') {\n        return x;\n      }\n      x.argument = replaceReturnedExpression(x.argument);\n      return x;\n    }\n    if ((x === null || x === void 0 ? void 0 : x.expression.type) === 'LogicalExpression') {\n      if (x.expression.right.type !== 'Literal') {\n        x.expression.right = replaceReturnedExpression(x.expression.right);\n      }\n      if (x.expression.left.type !== 'Literal') {\n        x.expression.left = replaceReturnedExpression(x.expression.left);\n      }\n      return x;\n    }\n    if ((x === null || x === void 0 ? void 0 : x.expression.type) === 'ConditionalExpression') {\n      x.expression.consequent = replaceReturnedExpression(x.expression.consequent);\n      x.expression.alternate = replaceReturnedExpression(x.expression.alternate);\n      return x;\n    }\n    if ((x === null || x === void 0 ? void 0 : x.expression.type) === 'AssignmentExpression') {\n      return x;\n    }\n    if (((_e = (_d = x === null || x === void 0 ? void 0 : x.expression) === null || _d === void 0 ? void 0 : _d.callee) === null || _e === void 0 ? void 0 : _e.object.type) === 'MemberExpression') {\n      device_variable = x.expression.callee.object.object.name;\n    } else if (((_h = (_g = (_f = x === null || x === void 0 ? void 0 : x.expression) === null || _f === void 0 ? void 0 : _f.callee) === null || _g === void 0 ? void 0 : _g.object) === null || _h === void 0 ? void 0 : _h.type) === 'Identifier') {\n      device_variable = x.expression.callee.object.name;\n    } else {\n      device_variable = '';\n    }\n    if (((_k = (_j = x === null || x === void 0 ? void 0 : x.expression) === null || _j === void 0 ? void 0 : _j.object) === null || _k === void 0 ? void 0 : _k.type) === 'ThisExpression') {\n      return x;\n    }\n    if (!esp_initialising_vars.map(x => x.name).includes(device_variable)) {\n      if ((x === null || x === void 0 ? void 0 : x.expression.arguments) instanceof Array) {\n        x.expression.arguments = x.expression.arguments.map(y => {\n          if (y.hasOwnProperty('value')) {\n            return y.value;\n          } else {\n            if (y.body.hasOwnProperty('body')) {\n              y.body.body = y.body.body.map(z => replaceExpression(z));\n            }\n            return y;\n          }\n        });\n      }\n      return x;\n    } else {\n      let device_init = esp_initialising_vars.find(x => x.name === device_variable);\n      let phrase = device_init.initialiser + '.';\n      if ((_l = x.expression.callee.object.property) === null || _l === void 0 ? void 0 : _l.name) {\n        phrase += ((_m = x.expression.callee.object.property) === null || _m === void 0 ? void 0 : _m.name) && ((_o = x.expression.callee.object.property) === null || _o === void 0 ? void 0 : _o.name) + '.';\n      }\n      let params = x.expression.arguments.map(x => {\n        if (x.hasOwnProperty('value')) {\n          return x.value;\n        } else {\n          let transformer_out = (0, exports.transformer)(x.body, {\n            additional_callees: getInstanceInitialising(ast)\n          });\n          return (0, generator_1.generator)(transformer_out, {\n            additional_callees: []\n          });\n        }\n      });\n      phrase += x.expression.callee.property.name;\n      let ast_res = convertToAST(phrase, params);\n      return ast_res;\n    }\n  };\n  const removeInitsAndImports = ast => {\n    var _a, _b, _c, _d;\n    let val;\n    switch (ast.type) {\n      case 'ImportDeclaration':\n        {\n          val = ast.source.value.includes('espruino-tools') ? '' : ast;\n          break;\n        }\n      case 'VariableDeclaration':\n        {\n          if (((_a = ast.declarations[0].init) === null || _a === void 0 ? void 0 : _a.type) === 'FunctionExpression') {\n            ast.declarations[0].init.body.body = ast.declarations[0].init.body.body.map(x => replaceExpression(x));\n          }\n          if (((_b = ast.declarations[0].init) === null || _b === void 0 ? void 0 : _b.type) === 'ObjectExpression') {\n            ast.declarations[0].init.properties = ast.declarations[0].init.properties.map(x => {\n              if (x.value.type === 'FunctionExpression') {\n                x.value = replaceLoopStatement(x.value);\n              } else if (x.value.type === 'CallExpression') {\n                x.value = replaceReturnedExpression(x.value);\n              } else if (x.value.type === 'ArrowFunctionExpression') {\n                x.value.body = replaceReturnedExpression(x.value.body);\n              }\n              return x;\n            });\n          }\n          if (((_c = ast.declarations[0].init) === null || _c === void 0 ? void 0 : _c.type) === 'ArrowFunctionExpression') {\n            if (ast.declarations[0].init.body.body instanceof Array) {\n              ast.declarations[0].init.body.body = ast.declarations[0].init.body.body.map(x => replaceExpression(x));\n            } else {\n              ast.declarations[0].init.body = replaceReturnedExpression(ast.declarations[0].init.body);\n            }\n          }\n          if (ast.declarations[0].init.hasOwnProperty('callee')) {\n            val = callee_names.includes((_d = ast.declarations[0].init.callee) === null || _d === void 0 ? void 0 : _d.name) ? '' : ast;\n          } else {\n            val = ast;\n          }\n          break;\n        }\n      default:\n        return ast;\n    }\n    return val;\n  };\n  const replaceIfExpressions = x => {\n    let x_copy = Object.assign({}, x);\n    if (x_copy.type === 'BlockStatement') {\n      x_copy.body = x_copy.body.map(y => replaceExpression(y));\n    }\n    if (x_copy.type === 'IfStatement') {\n      return replaceIfStatement(x_copy);\n    }\n    return x_copy;\n  };\n  const replaceIfStatement = x => {\n    let if_copy = Object.assign({}, x);\n    if_copy.consequent = replaceIfExpressions(x.consequent);\n    if (if_copy.alternate) {\n      if_copy.alternate = replaceIfExpressions(x.alternate);\n    }\n    return if_copy;\n  };\n  const replaceLoopStatement = x => {\n    let loop_copy = Object.assign({}, x);\n    loop_copy.body.body = loop_copy.body.body.map(y => replaceExpression(y));\n    return loop_copy;\n  };\n  const replaceSwitchStatement = x => {\n    let switch_copy = Object.assign({}, x);\n    switch_copy.cases = switch_copy.cases.map(y => y.consequent = y.consequent.map(z => replaceExpression(z)));\n    return x;\n  };\n  const replaceClass = x => {\n    let class_copy = Object.assign({}, x);\n    class_copy.body.body = class_copy.body.body.map(y => {\n      y.value = replaceLoopStatement(y.value);\n      return y;\n    });\n    return class_copy;\n  };\n  const replaceTryCatch = x => {\n    x.block.body = x.block.body.map(y => {\n      return replaceExpression(y);\n    });\n    x.handler.body.body = x.handler.body.body.map(y => {\n      return replaceExpression(y);\n    });\n    return x;\n  };\n  const getExpressions = ast => {\n    let ast_copy = Object.assign({}, ast);\n    ast_copy.body = ast.body.map(x => {\n      switch (x.type) {\n        case 'ExpressionStatement':\n          {\n            return replaceExpression(x);\n          }\n        case 'TryStatement':\n          {\n            return replaceTryCatch(x);\n          }\n        case 'IfStatement':\n          {\n            return replaceIfStatement(x);\n          }\n        case 'ClassDeclaration':\n          return replaceClass(x);\n        case 'FunctionDeclaration':\n        case 'WhileStatement':\n        case 'ForStatement':\n        case 'ForInStatement':\n        case 'AsyncFunctionDeclaration':\n        case 'DoWhileStatement':\n          {\n            return replaceLoopStatement(x);\n          }\n        case 'SwitchStatement':\n          return replaceSwitchStatement(x);\n        default:\n          {\n            return removeInitsAndImports(x);\n          }\n      }\n    }).filter(x => x !== '');\n    return ast_copy;\n  };\n  return getExpressions(ast);\n};\nexports.transformer = transformer;","map":{"version":3,"names":["Object","defineProperty","exports","value","transformer","mappings_1","require","esprima","generator_1","ast","options","callee_names","additional_initialisers","getInstanceInitialising","variable_declarations","body","filter","x","type","esp_inititalising_vars","_a","includes","declarations","init","callee","name","callees","map","id","initialiser","additional_callees","convertToAST","code","params","code_arr","split","expression_func","reduce","prev","curr","mappings","parseScript","replaceReturnedExpression","_b","_c","_d","_e","_f","esp_initialising_vars","device_variable","object","device_init","find","phrase","property","arguments","y","hasOwnProperty","transformer_out","generator","ast_res","replaceExpression","_g","_h","_j","_k","_l","_m","_o","replaceIfStatement","replaceClass","replaceLoopStatement","replaceSwitchStatement","properties","argument","expression","right","left","consequent","alternate","Array","z","removeInitsAndImports","val","source","replaceIfExpressions","x_copy","assign","if_copy","loop_copy","switch_copy","cases","class_copy","replaceTryCatch","block","handler","getExpressions","ast_copy"],"sources":["C:/Users/Ting Xian Hao/OneDrive/Documents/GitHub/Team9B/oip9b/node_modules/@espruino-tools/transpiler/lib/transformer.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.transformer = void 0;\nconst mappings_1 = require(\"./mappings\");\nconst esprima = require(\"esprima\");\nconst generator_1 = require(\"./generator\");\n/**\n * This will replace code in AST pre-rebuilding\n * @param ast\n */\nconst transformer = (ast, options) => {\n    let callee_names = [\n        'Puck',\n        'Pixl',\n        'Bangle',\n        'DeviceController',\n        ...(options.additional_initialisers\n            ? options.additional_initialisers\n            : []),\n    ];\n    const getInstanceInitialising = (ast) => {\n        let variable_declarations = ast.body.filter((x) => x.type == 'VariableDeclaration');\n        let esp_inititalising_vars = variable_declarations.filter((x) => { var _a; return callee_names.includes((_a = x.declarations[0].init.callee) === null || _a === void 0 ? void 0 : _a.name); });\n        let callees = [\n            ...esp_inititalising_vars.map((x) => ({\n                name: x.declarations[0].id.name,\n                initialiser: x.declarations[0].init.callee.name,\n            })),\n            ...options.additional_callees,\n        ];\n        return callees;\n    };\n    const convertToAST = (code, params) => {\n        let code_arr = code.split('.');\n        let expression_func = code_arr.reduce((prev, curr) => prev[curr], mappings_1.mappings);\n        return esprima.parseScript(expression_func(...params)).body[0];\n    };\n    const replaceReturnedExpression = (x) => {\n        var _a, _b, _c, _d, _e, _f;\n        if ((x === null || x === void 0 ? void 0 : x.type) === 'Identifier') {\n            return x;\n        }\n        let esp_initialising_vars = getInstanceInitialising(ast);\n        let device_variable = (_c = (_b = (_a = x === null || x === void 0 ? void 0 : x.callee) === null || _a === void 0 ? void 0 : _a.object) === null || _b === void 0 ? void 0 : _b.object) === null || _c === void 0 ? void 0 : _c.name;\n        let device_init = esp_initialising_vars.find((x) => x.name === device_variable);\n        let phrase = device_init.initialiser + '.';\n        if ((_d = x.callee.object.property) === null || _d === void 0 ? void 0 : _d.name) {\n            phrase +=\n                ((_e = x.callee.object.property) === null || _e === void 0 ? void 0 : _e.name) && ((_f = x.callee.object.property) === null || _f === void 0 ? void 0 : _f.name) + '.';\n        }\n        let params = x.arguments.map((y) => {\n            if (y.hasOwnProperty('value')) {\n                return y.value;\n            }\n            else {\n                let transformer_out = (0, exports.transformer)(x.body, {\n                    additional_callees: getInstanceInitialising(ast),\n                });\n                return (0, generator_1.generator)(transformer_out, {\n                    additional_callees: [],\n                });\n            }\n        });\n        phrase += x.callee.property.name;\n        let ast_res = convertToAST(phrase, params);\n        return ast_res;\n    };\n    const replaceExpression = (x) => {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;\n        let esp_initialising_vars = getInstanceInitialising(ast);\n        let device_variable;\n        switch (x === null || x === void 0 ? void 0 : x.type) {\n            case 'IfStatement': {\n                return replaceIfStatement(x);\n            }\n            case 'ClassDeclaration':\n                return replaceClass(x);\n            case 'FunctionDeclaration':\n            case 'WhileStatement':\n            case 'ForStatement':\n            case 'ForInStatement':\n            case 'DoWhileStatement': {\n                return replaceLoopStatement(x);\n            }\n            case 'SwitchStatement':\n                return replaceSwitchStatement(x);\n            case 'ContinueStatement':\n            case 'BreakStatement':\n                return x;\n        }\n        if ((x === null || x === void 0 ? void 0 : x.type) === 'VariableDeclaration') {\n            if (((_a = x.declarations[0].init) === null || _a === void 0 ? void 0 : _a.type) === 'FunctionExpression') {\n                x.declarations[0].init.body.body = x.declarations[0].init.body.body.map((y) => replaceExpression(y));\n            }\n            if (((_b = x.declarations[0].init) === null || _b === void 0 ? void 0 : _b.type) === 'AwaitExpression') {\n                return x;\n            }\n            if (((_c = x.declarations[0].init) === null || _c === void 0 ? void 0 : _c.type) === 'ObjectExpression') {\n                x.declarations[0].init.properties =\n                    x.declarations[0].init.properties.map((y) => {\n                        if (y.value.type === 'FunctionExpression') {\n                            y.value = replaceLoopStatement(y.value);\n                        }\n                        else if (y.value.type === 'CallExpression') {\n                            y.value = replaceReturnedExpression(y.value);\n                        }\n                        else if (x.value.type === 'ArrowFunctionExpression') {\n                            y.value.body = replaceReturnedExpression(y.value.body);\n                        }\n                        return y;\n                    });\n                return x;\n            }\n        }\n        if ((x === null || x === void 0 ? void 0 : x.type) === 'ReturnStatement') {\n            if (x.argument.type === 'Literal') {\n                return x;\n            }\n            x.argument = replaceReturnedExpression(x.argument);\n            return x;\n        }\n        if ((x === null || x === void 0 ? void 0 : x.expression.type) === 'LogicalExpression') {\n            if (x.expression.right.type !== 'Literal') {\n                x.expression.right = replaceReturnedExpression(x.expression.right);\n            }\n            if (x.expression.left.type !== 'Literal') {\n                x.expression.left = replaceReturnedExpression(x.expression.left);\n            }\n            return x;\n        }\n        if ((x === null || x === void 0 ? void 0 : x.expression.type) === 'ConditionalExpression') {\n            x.expression.consequent = replaceReturnedExpression(x.expression.consequent);\n            x.expression.alternate = replaceReturnedExpression(x.expression.alternate);\n            return x;\n        }\n        if ((x === null || x === void 0 ? void 0 : x.expression.type) === 'AssignmentExpression') {\n            return x;\n        }\n        if (((_e = (_d = x === null || x === void 0 ? void 0 : x.expression) === null || _d === void 0 ? void 0 : _d.callee) === null || _e === void 0 ? void 0 : _e.object.type) === 'MemberExpression') {\n            device_variable = x.expression.callee.object.object.name;\n        }\n        else if (((_h = (_g = (_f = x === null || x === void 0 ? void 0 : x.expression) === null || _f === void 0 ? void 0 : _f.callee) === null || _g === void 0 ? void 0 : _g.object) === null || _h === void 0 ? void 0 : _h.type) === 'Identifier') {\n            device_variable = x.expression.callee.object.name;\n        }\n        else {\n            device_variable = '';\n        }\n        if (((_k = (_j = x === null || x === void 0 ? void 0 : x.expression) === null || _j === void 0 ? void 0 : _j.object) === null || _k === void 0 ? void 0 : _k.type) === 'ThisExpression') {\n            return x;\n        }\n        if (!esp_initialising_vars.map((x) => x.name).includes(device_variable)) {\n            if ((x === null || x === void 0 ? void 0 : x.expression.arguments) instanceof Array) {\n                x.expression.arguments = x.expression.arguments.map((y) => {\n                    if (y.hasOwnProperty('value')) {\n                        return y.value;\n                    }\n                    else {\n                        if (y.body.hasOwnProperty('body')) {\n                            y.body.body = y.body.body.map((z) => replaceExpression(z));\n                        }\n                        return y;\n                    }\n                });\n            }\n            return x;\n        }\n        else {\n            let device_init = esp_initialising_vars.find((x) => x.name === device_variable);\n            let phrase = device_init.initialiser + '.';\n            if ((_l = x.expression.callee.object.property) === null || _l === void 0 ? void 0 : _l.name) {\n                phrase +=\n                    ((_m = x.expression.callee.object.property) === null || _m === void 0 ? void 0 : _m.name) &&\n                        ((_o = x.expression.callee.object.property) === null || _o === void 0 ? void 0 : _o.name) + '.';\n            }\n            let params = x.expression.arguments.map((x) => {\n                if (x.hasOwnProperty('value')) {\n                    return x.value;\n                }\n                else {\n                    let transformer_out = (0, exports.transformer)(x.body, {\n                        additional_callees: getInstanceInitialising(ast),\n                    });\n                    return (0, generator_1.generator)(transformer_out, {\n                        additional_callees: [],\n                    });\n                }\n            });\n            phrase += x.expression.callee.property.name;\n            let ast_res = convertToAST(phrase, params);\n            return ast_res;\n        }\n    };\n    const removeInitsAndImports = (ast) => {\n        var _a, _b, _c, _d;\n        let val;\n        switch (ast.type) {\n            case 'ImportDeclaration': {\n                val = ast.source.value.includes('espruino-tools') ? '' : ast;\n                break;\n            }\n            case 'VariableDeclaration': {\n                if (((_a = ast.declarations[0].init) === null || _a === void 0 ? void 0 : _a.type) === 'FunctionExpression') {\n                    ast.declarations[0].init.body.body =\n                        ast.declarations[0].init.body.body.map((x) => replaceExpression(x));\n                }\n                if (((_b = ast.declarations[0].init) === null || _b === void 0 ? void 0 : _b.type) === 'ObjectExpression') {\n                    ast.declarations[0].init.properties =\n                        ast.declarations[0].init.properties.map((x) => {\n                            if (x.value.type === 'FunctionExpression') {\n                                x.value = replaceLoopStatement(x.value);\n                            }\n                            else if (x.value.type === 'CallExpression') {\n                                x.value = replaceReturnedExpression(x.value);\n                            }\n                            else if (x.value.type === 'ArrowFunctionExpression') {\n                                x.value.body = replaceReturnedExpression(x.value.body);\n                            }\n                            return x;\n                        });\n                }\n                if (((_c = ast.declarations[0].init) === null || _c === void 0 ? void 0 : _c.type) === 'ArrowFunctionExpression') {\n                    if (ast.declarations[0].init.body.body instanceof Array) {\n                        ast.declarations[0].init.body.body =\n                            ast.declarations[0].init.body.body.map((x) => replaceExpression(x));\n                    }\n                    else {\n                        ast.declarations[0].init.body = replaceReturnedExpression(ast.declarations[0].init.body);\n                    }\n                }\n                if (ast.declarations[0].init.hasOwnProperty('callee')) {\n                    val = callee_names.includes((_d = ast.declarations[0].init.callee) === null || _d === void 0 ? void 0 : _d.name)\n                        ? ''\n                        : ast;\n                }\n                else {\n                    val = ast;\n                }\n                break;\n            }\n            default:\n                return ast;\n        }\n        return val;\n    };\n    const replaceIfExpressions = (x) => {\n        let x_copy = Object.assign({}, x);\n        if (x_copy.type === 'BlockStatement') {\n            x_copy.body = x_copy.body.map((y) => replaceExpression(y));\n        }\n        if (x_copy.type === 'IfStatement') {\n            return replaceIfStatement(x_copy);\n        }\n        return x_copy;\n    };\n    const replaceIfStatement = (x) => {\n        let if_copy = Object.assign({}, x);\n        if_copy.consequent = replaceIfExpressions(x.consequent);\n        if (if_copy.alternate) {\n            if_copy.alternate = replaceIfExpressions(x.alternate);\n        }\n        return if_copy;\n    };\n    const replaceLoopStatement = (x) => {\n        let loop_copy = Object.assign({}, x);\n        loop_copy.body.body = loop_copy.body.body.map((y) => replaceExpression(y));\n        return loop_copy;\n    };\n    const replaceSwitchStatement = (x) => {\n        let switch_copy = Object.assign({}, x);\n        switch_copy.cases = switch_copy.cases.map((y) => (y.consequent = y.consequent.map((z) => replaceExpression(z))));\n        return x;\n    };\n    const replaceClass = (x) => {\n        let class_copy = Object.assign({}, x);\n        class_copy.body.body = class_copy.body.body.map((y) => {\n            y.value = replaceLoopStatement(y.value);\n            return y;\n        });\n        return class_copy;\n    };\n    const replaceTryCatch = (x) => {\n        x.block.body = x.block.body.map((y) => {\n            return replaceExpression(y);\n        });\n        x.handler.body.body = x.handler.body.body.map((y) => {\n            return replaceExpression(y);\n        });\n        return x;\n    };\n    const getExpressions = (ast) => {\n        let ast_copy = Object.assign({}, ast);\n        ast_copy.body = ast.body\n            .map((x) => {\n            switch (x.type) {\n                case 'ExpressionStatement': {\n                    return replaceExpression(x);\n                }\n                case 'TryStatement': {\n                    return replaceTryCatch(x);\n                }\n                case 'IfStatement': {\n                    return replaceIfStatement(x);\n                }\n                case 'ClassDeclaration':\n                    return replaceClass(x);\n                case 'FunctionDeclaration':\n                case 'WhileStatement':\n                case 'ForStatement':\n                case 'ForInStatement':\n                case 'AsyncFunctionDeclaration':\n                case 'DoWhileStatement': {\n                    return replaceLoopStatement(x);\n                }\n                case 'SwitchStatement':\n                    return replaceSwitchStatement(x);\n                default: {\n                    return removeInitsAndImports(x);\n                }\n            }\n        })\n            .filter((x) => x !== '');\n        return ast_copy;\n    };\n    return getExpressions(ast);\n};\nexports.transformer = transformer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}